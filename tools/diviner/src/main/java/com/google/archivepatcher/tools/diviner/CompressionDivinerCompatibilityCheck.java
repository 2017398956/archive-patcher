// Copyright 2015 Google Inc. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.archivepatcher.tools.diviner;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.zip.Deflater;

import com.google.archivepatcher.AbstractArchiveTool;
import com.google.archivepatcher.MicroOptions;
import com.google.archivepatcher.compression.DeflateCompressor;
import com.google.archivepatcher.compression.JreDeflateParameters;


/**
 * A tool to quickly check for the compatibility of this platform with the
 * compression diviner.
 */
public class CompressionDivinerCompatibilityCheck extends AbstractArchiveTool {
    /**
     * The baseline that this tool expects to find on all compatible systems.
     * <p>
     * This string is a series of lines, each of which contains a
     * comma-separated list of {@link JreDeflateParameters} and a SHA-256 of the
     * result of compressing the corpus with those parameters.
     * <p>
     * This can be regenerated by running the tool with the "--baseline-code"
     * argument.
     */
    // Generated on 2015-11-27 using Oracle's Java RuntimeEnvironment:
    // Java(TM) SE Runtime Environment (build 1.8.0_66-b18)
    // Java HotSpot(TM) 64-Bit Server VM (build 25.66-b18, mixed mode)
    public final static String BASELINE =
        "level=1,strategy=0,nowrap=true,sha256=5e0ae60766a04b0c9ef1f677ae4ba4a83a6bc112ce3761b41b270af08821804e\n" +
        "level=2,strategy=0,nowrap=true,sha256=9b392414e62afcc64200cc39955ff75d1254f56c67bf2eb05d62f63b677080fc\n" +
        "level=3,strategy=0,nowrap=true,sha256=ce272e7f72232e80b5d00d7333a5bdd6e9d7e34268d49c5fe9bdfedba6fc0d54\n" +
        "level=4,strategy=0,nowrap=true,sha256=a8a3b59d42fe257766926d46818422216a043c8c37bb69492d9bab3bd4d6b07a\n" +
        "level=5,strategy=0,nowrap=true,sha256=49280186dd6683ae92ef25e239d7c0e2b7a4fd0e2b7dfadc8846f5157aa6aed9\n" +
        "level=6,strategy=0,nowrap=true,sha256=bec508de691537047e338825828db16308cc8dc93e22386c8eeb0bc14c4c5f45\n" +
        "level=7,strategy=0,nowrap=true,sha256=6daf3724aed1f67c7d1f6404166b5dbea1f2fc42192f20813910271bc8c40e75\n" +
        "level=8,strategy=0,nowrap=true,sha256=08cd258637bb146d33ef550fc60baaa855902837758d6489802f3b1ece6ea7f1\n" +
        "level=9,strategy=0,nowrap=true,sha256=5ea67964bb124b436130dfbbd2e36fb2b08992423be188a8edfbb8550e8bfefb\n" +
        "level=1,strategy=1,nowrap=true,sha256=5e0ae60766a04b0c9ef1f677ae4ba4a83a6bc112ce3761b41b270af08821804e\n" +
        "level=2,strategy=1,nowrap=true,sha256=9b392414e62afcc64200cc39955ff75d1254f56c67bf2eb05d62f63b677080fc\n" +
        "level=3,strategy=1,nowrap=true,sha256=ce272e7f72232e80b5d00d7333a5bdd6e9d7e34268d49c5fe9bdfedba6fc0d54\n" +
        "level=4,strategy=1,nowrap=true,sha256=6283bb35a97f4657b6aab0b0a7f218947965f135838926df295037fdca816746\n" +
        "level=5,strategy=1,nowrap=true,sha256=42594bbcf7fa83f74cdf35839debaae25e4655070fdf1fc67539de0a90f59afe\n" +
        "level=6,strategy=1,nowrap=true,sha256=1db82cae52b0bb88cf3a21cdec183c1dab8074b1d1f4341b9e9b18b1ace5a778\n" +
        "level=7,strategy=1,nowrap=true,sha256=5d0d53667944dc447b52e58b0e91e303b5662f92a085ab5a1f4b62eeab8900ef\n" +
        "level=8,strategy=1,nowrap=true,sha256=c6cdfbe16b1e530e91fd3ac1dbb2a9b2f5b3ccee5ddf92769ea349fc60fd560e\n" +
        "level=9,strategy=1,nowrap=true,sha256=f4e93a15b50c568d39785c12d373104272009bcd71028dbf0faa85441eb5130d\n" +
        "level=1,strategy=2,nowrap=true,sha256=2297dbc0a5498c9a7a89519f401936e910ddb82c9b477e7aa407a4c2bf523dbd\n" +
        "level=1,strategy=0,nowrap=false,sha256=5e06d9c9280e5b9b4832c0894e2f930f606665169ad2ac093df544e70fac4136\n" +
        "level=2,strategy=0,nowrap=false,sha256=f1c2fe9b4189c03a5ae0b1a1db51875d334fb21144e08e9c527644d66ef39797\n" +
        "level=3,strategy=0,nowrap=false,sha256=49998ee364d2668eb5a2cadf40feaa78c0c081337141ad15f7fb2a7843c833b8\n" +
        "level=4,strategy=0,nowrap=false,sha256=6911a5b04664b00b2bba72d7ba9e1d5a73b390f2cf4b20618580c13a5825fc17\n" +
        "level=5,strategy=0,nowrap=false,sha256=417f5fd21438ffb739a681af9a20eed29dd9da63e8a540415b9ec6199495e6db\n" +
        "level=6,strategy=0,nowrap=false,sha256=9a4bcc9afd8547784aff6283cafd69f46893d5131bd798fbad92dc52ca946522\n" +
        "level=7,strategy=0,nowrap=false,sha256=592ad846a99693b2f1092bac6a3bf2cf5ac562a9b38ebe34c46cbf2ddd3c13aa\n" +
        "level=8,strategy=0,nowrap=false,sha256=8d4b91929384dfd7a0dda6b6e0410de7c4c109167047d694cf36b46e68dd8d5f\n" +
        "level=9,strategy=0,nowrap=false,sha256=36bacacc32707e6498269a04d2b2cd30990ac4b0717ee4a9e4badbb6ca5fb7ea\n" +
        "level=1,strategy=1,nowrap=false,sha256=5e06d9c9280e5b9b4832c0894e2f930f606665169ad2ac093df544e70fac4136\n" +
        "level=2,strategy=1,nowrap=false,sha256=f1c2fe9b4189c03a5ae0b1a1db51875d334fb21144e08e9c527644d66ef39797\n" +
        "level=3,strategy=1,nowrap=false,sha256=49998ee364d2668eb5a2cadf40feaa78c0c081337141ad15f7fb2a7843c833b8\n" +
        "level=4,strategy=1,nowrap=false,sha256=2bd9ae26fe933102ed46ef2bf8e82d62e0104d9d1cce73a8b46df8a238fd32f8\n" +
        "level=5,strategy=1,nowrap=false,sha256=6410581a92808f97f695e796c2963cb6e111af1ec7b7e7d155dcb601192dd80a\n" +
        "level=6,strategy=1,nowrap=false,sha256=50571149806edb22b7f3a3ba52168644dd99de444e813df7e186817ccc204c01\n" +
        "level=7,strategy=1,nowrap=false,sha256=7a41b9549bcc651d3d219e7aaf3f74beefea238caf1560036cd299d62be6531b\n" +
        "level=8,strategy=1,nowrap=false,sha256=29da81b218ff50e69819375d2c008a648309dd9a0fc18683d675ce523cff744f\n" +
        "level=9,strategy=1,nowrap=false,sha256=4ce8c7903e526e2a36db168c5cf9af0b90155850899ea26ad77d6daaa7b395c3\n" +
        "level=1,strategy=2,nowrap=false,sha256=e3cc7200f308fa7756f02bebbf5046e58a4a2a7e8f1c9ea1708b96d4e1033666";

    /**
     * Corpus of text for compression.
     */
    private final static String CORPUS_TEXT =
        "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do " +
        "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim " +
        "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut " +
        "aliquip ex ea commodo consequat. Duis aute irure dolor in " +
        "reprehenderit in voluptate velit esse cillum dolore eu fugiat " +
        "nulla pariatur. Excepteur sint occaecat cupidatat non proident, " +
        "sunt in culpa qui officia deserunt mollit anim id est laborum.";

    /**
     * Main method. For usage instructions, run with "--help".
     * 
     * @param args arguments to the program
     * @throws Exception if anything goes wrong
     */
    public final static void main(String... args) throws Exception {
        new CompressionDivinerCompatibilityCheck().run(args);
    }

    /**
     * Manufacture a well-known corpus of data that can be compressed with
     * various engines to produce results that should be deterministic on a
     * given platform. Comparing the SHA-256 of the compressed variants of this
     * data to the well-known SHA-256es for the compression outputs on a given
     * platform will determine whether or not that platform has a perfectly
     * reproducible compression implementation.
     * <p>
     * Some configurations of deflate will produce identical output. This is
     * because there is some overlap between the various things (e.g., maximum
     * match length) at various combinations of parameters. Most notably, there
     * is no concept of compression "level" with the
     * {@link Deflater#HUFFMAN_ONLY} strategy.
     * @return the corpus
     */
    private final static byte[] generateCorpus() {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        final byte[] loremIpsumBytes;
        try {
            loremIpsumBytes = CORPUS_TEXT.getBytes("US-ASCII");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("System doesn't support ASCII", e);
        }
        // This is sufficient to create different results for all 9 compression
        // levels of the default strategy by exercising the hash chaining
        // longest-match logic in zlib. The data totals about 9k.
        for (int x=0; x<135; x++) {
            buffer.write(loremIpsumBytes, 0, x);
        }
        return buffer.toByteArray();
    }

    @Override
    public final void configureOptions(MicroOptions options) {
        options.option("baseline").isUnary().describedAs(
            "output information for rebaselining the tool and exit (uncommon)");
        options.option("baseline-code").isUnary().describedAs(
            "like --baseline but outputs copy/paste-able Java code (for devs)");
    }

    @Override
    protected final void run(MicroOptions options) throws Exception {
        if (options.has("baseline")) {
            emitBaseline();
        } else if (options.has("baseline-code")) {
            emitBaselineCode();
        } else {
            if (!isCompatible()) {
                System.exit(-1);
            }
        }
    }

    /**
     * Checks for compatibility with the baseline.
     * @return true if compatible, otherwise false.
     */
    private final boolean isCompatible() {
        try {
            Map<JreDeflateParameters, String> baseline = readBaseline();
            Map<JreDeflateParameters, String> computed = compute();
            final boolean compatible = computed.equals(baseline);
            if (compatible) {
                logVerbose("Compatible.");
            } else {
                logVerbose("Incompatible.");
            }
            if (isVerbose()) {
                StringBuilder buffer = new StringBuilder();
                for (JreDeflateParameters parameters : baseline.keySet()) {
                    final String baselineSHA256 = baseline.get(parameters);
                    final String computedSHA256 = computed.get(parameters);
                    final boolean matches =
                        baselineSHA256.equals(computedSHA256);
                    buffer.append(matches ? "OK   " : "FAIL ")
                        .append(parameters.toString())
                        .append(": baseline sha256=")
                        .append(baselineSHA256)
                        .append(", computed sha256=")
                        .append(computedSHA256)
                        .append("\n");
                }
                logVerbose(buffer.toString());
            }
            return compatible;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Emit baseline information to stdout.
     * @throws IOException if anything goes wrong
     */
    private final static void emitBaseline() throws IOException {
        final Iterator<Map.Entry<JreDeflateParameters, String>> iterator =
            compute().entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<JreDeflateParameters, String> oneResult = iterator.next();
            System.out.println(resultToString(
                oneResult.getKey(), oneResult.getValue()));
        }
    }

    /**
     * Emit source code for a new baseline to stdout.
     * @throws IOException if anything goes wrong
     */
    private final static void emitBaselineCode() throws IOException {
        StringBuilder buffer = new StringBuilder();
        buffer.append("    public final static String BASELINE =\n");
        final Iterator<Map.Entry<JreDeflateParameters, String>> iterator =
            compute().entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<JreDeflateParameters, String> oneResult = iterator.next();
            final JreDeflateParameters params = oneResult.getKey();
            final String sha256 = oneResult.getValue();
            buffer.append("        \"");
            buffer.append(resultToString(params, sha256));
            if (iterator.hasNext()) {
                buffer.append("\\n\" +\n");
            } else {
                buffer.append("\";");
            }
        }
        System.out.println(buffer);
    }

    /**
     * Iterate over all possible configurations of the deflate compressor using
     * the built-in corpus and return a mapping of each unique configuration's
     * resulting SHA256.
     * @return the mapping as described
     * @throws IOException if an error is encountered
     */
    private final static Map<JreDeflateParameters, String> compute()
        throws IOException {
        final boolean[] nowrapValues = {true, false};
        final int[] strategies = {Deflater.DEFAULT_STRATEGY,
                Deflater.FILTERED, Deflater.HUFFMAN_ONLY};
        final int[] levels = {1,2,3,4,5,6,7,8,9};
        final Map<JreDeflateParameters, String> result =
            new LinkedHashMap<JreDeflateParameters, String>();
        final byte[] corpus = generateCorpus();
        for (final boolean nowrap : nowrapValues) {
            for (final int strategy : strategies) {
                final int[] relevantLevels;
                if (strategy == Deflater.HUFFMAN_ONLY) {
                    // There is no concept of a compression level with this
                    // strategy.
                    relevantLevels = new int[] {1};
                } else {
                    relevantLevels = levels;
                }
                for (final int level : relevantLevels) {
                    JreDeflateParameters parameters = new JreDeflateParameters(
                        level, strategy, nowrap);
                    DeflateCompressor compressor = new DeflateCompressor();
                    compressor.setCompressionLevel(level);
                    compressor.setStrategy(strategy);
                    compressor.setNowrap(nowrap);
                    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
                    compressor.compress(new ByteArrayInputStream(corpus),
                        buffer);
                    byte[] compressedData = buffer.toByteArray();
                    byte[] sha256OfCompressedData;
                    try {
                        sha256OfCompressedData =
                            MessageDigest.getInstance("SHA-256")
                                .digest(compressedData);
                    } catch (NoSuchAlgorithmException e) {
                        throw new RuntimeException(
                            "System doesn't support SHA-256", e);
                    }
                    String sha256String = hexString(sha256OfCompressedData);
                    result.put(parameters, sha256String);
                }
            }
        }
        return result;
    }

    /**
     * Convert one result to a string.
     * @param parameters the jre deflate parameters that were used
     * @param sha256 the sha256 that resulted
     * @return a string representation of the result
     */
    private final static String resultToString(
        final JreDeflateParameters parameters, final String sha256) {
        StringBuilder buffer = new StringBuilder(parameters.toString());
        buffer.append(",sha256=").append(sha256);
        return buffer.toString();
    }

    /**
     * Read {@link #BASELINE} and convert it back into a mapping of parameters
     * to SHA256 values.
     * @return the mapping
     */
    private final static Map<JreDeflateParameters, String> readBaseline() {
        Map<JreDeflateParameters, String> result =
            new LinkedHashMap<JreDeflateParameters, String>();
        String[] lines = BASELINE.split("\n");
        for (String line : lines) {
            JreDeflateParameters parameters =
                JreDeflateParameters.parseJreDeflateParameters(line);
            int lastComma = line.lastIndexOf(',');
            String sha256 = line.substring(lastComma+1);
            sha256 = sha256.substring(sha256.indexOf('=') + 1);
            result.put(parameters, sha256);
        }
        return result;
    }

    /**
     * Convert the specified bytes to a fixed-length hex string.
     * @param bytes the bytes to convert
     * @return a string exactly twice as long as the number of bytes in the
     * input, representing the bytes as a continuous hexadecimal stream
     */
    private final static String hexString(byte[] bytes) {
        StringBuilder buffer = new StringBuilder();
        for (int x=0; x<bytes.length; x++) {
            int value = bytes[x] & 0xff;
            if (value < 0x10) {
                buffer.append('0');
            }
            buffer.append(Integer.toHexString(value));
        }
        return buffer.toString();
    }
}