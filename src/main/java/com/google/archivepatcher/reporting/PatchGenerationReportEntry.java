// Copyright 2015 Google Inc. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.archivepatcher.reporting;

import java.util.HashMap;
import java.util.Map;

import com.google.archivepatcher.compression.BuiltInCompressionEngine;
import com.google.archivepatcher.delta.BuiltInDeltaEngine;
import com.google.archivepatcher.patcher.PatchCommand;

/**
 * One entry in a {@link PatchGenerationReport}. Contains all the information
 * about what was attempted and ultimately chosen as the patch representation
 * for each resource evaluated during patch processing.
 */
public class PatchGenerationReportEntry {
    /**
     * The path in the old archive.
     */
    private final String oldPath;

    /**
     * The path in the new archive.
     */
    private final String newPath;

    /**
     * The command generated for the patch.
     */
    private PatchCommand command;

    /**
     * The size of the resource in the old archive, as it exists in that
     * archive (if the resource is compressed, this is the compressed size;
     * if the resource is uncompressed, this is the uncompressed size).
     */
    private final int oldArchiveSizeBytes;

    /**
     * The ID of the compression engine used in the old archive for this
     * resource.
     */
    private final int oldArchiveCompressionEngineId;

    /**
     * The size of the resource in the new archive, as it exists in that
     * archive (if the resource is compressed, this is the compressed size;
     * if the resource is uncompressed, this is the uncompressed size).
     */
    private final int newArchiveSizeBytes;

    /**
     * The ID of the compression engine used in the new archive for this
     * resource.
     */
    private final int newArchiveCompressionEngineId;

    /**
     * The final (possibly compressed) sizes of the deltas generated by each
     * strategy that was attempted.
     */
    private final Map<Strategy, Integer> deltaSizeBytesByStrategy =
        new HashMap<Strategy, Integer>();

    /**
     * The update method that was ultimately chosen for transfer.
     */
    private UpdateMethod chosenUpdateMethod = null;

    /**
     * The strategy that was ultimately chosen for performing a delta-based
     * update, if the {@link #chosenUpdateMethod} is
     * {@link UpdateMethod#DELTA_TRANSFER}.
     */
    private Strategy chosenDeltaTransferStrategy = null;

    /**
     * The ID of the compression engine that was ultimately chosen for
     * performing a full transfer update, if the {@link #chosenUpdateMethod} is
     * {@link UpdateMethod#FULL_TRANSFER}.
     */
    private Integer chosenFullTransferCompressionEngineId = null;

    /**
     * The ID of the compression engine that would be used to transfer the
     * entire resource over the wire in the absence of a delta-based update.
     * This is different than {@link #chosenFullTransferCompressionEngineId}.
     * @see #baselineWireTransferCompressedSize
     */
    private Integer baselineWireTransferCompressionEngineId = null;

    /**
     * The size of the resource as compressed using the compression engine
     * matching {@link #baselineWireTransferCompressionEngineId}, if known.
     * <p>
     * This value gives an indication of what would happen if the entire new
     * archive were transferred in a compressed format without patching
     * technology. Such a transfer would not make use of this patching tool,
     * thus the compression engine used for the transfer might be very different
     * from the compression engine this patching tool would use for an
     * equivalent transfer.
     * <p>
     * Example: An Android Package (APK) often contains uncompressed resources,
     * stored uncompressed for runtime efficiency reasons. It makes sense to
     * compress the <em>entire APK</em> for download, to save bandwidth. Such
     * compression is independent of any patching process, but is still highly
     * relevant: it provides a baseline for the savings that could be achieved
     * simply by compressing the entire archive prior to transfer. When talking
     * about the savings gained by using the patching tool, this number - the
     * baseline size for the wire transfer - is the number to beat.
     * 
     * @see #baselineWireTransferCompressionEngineId
     */
    private Integer baselineWireTransferCompressedSize = null;

    /**
     * Flag indicating that delta generation was attempted for the resource.
     */
    private boolean deltaGenerationAttempted = false;

    /**
     * Flag indicating that compression of the delta was attempted for the
     * resource.
     */
    private boolean deltaCompressionAttempted = false;

    /**
     * The full size of the entry as written to the patch, including any and
     * all fields.
     */
    private int fullEntrySizeBytes = 0;

    /**
     * Constructs a new entry.
     * @param oldPath the path of the resource in the old archive
     * @param newPath the path of the resource in the new archive
     * @param command the command that was generated for the resource
     * @param oldCompressionEngineId the ID of the compression engine used to
     * compress the resource (not the delta!) in the old archive
     * @param oldSizeBytes the size of the resource in the old archive. If a
     * compression engine was used in the old archive, this is the compressed
     * size of the resource; otherwise, it is the uncompressed size
     * @param newCompressionEngineId the ID of the compression engine used to
     * compress the resource (not the delta!) in the new archive
     * @param newSizeBytes the size of the resource in the new archive. If a
     * compression engine was used in the new archive, this is the compressed
     * size of the resource; otherwise, it is the uncompressed size
     */
    public PatchGenerationReportEntry(String oldPath, String newPath,
        PatchCommand command,
        int oldCompressionEngineId, int oldSizeBytes,
        int newCompressionEngineId, int newSizeBytes) {
        this.oldPath = oldPath;
        this.newPath = newPath;
        this.command = command;
        this.oldArchiveCompressionEngineId = oldCompressionEngineId;
        this.oldArchiveSizeBytes = oldSizeBytes;
        this.newArchiveCompressionEngineId = newCompressionEngineId;
        this.newArchiveSizeBytes = newSizeBytes;
    }

    /**
     * Sets the {@link Strategy} that was ultimately chosen for sending a
     * delta-based transfer. The {@link UpdateMethod} is automatically set to
     * {@link UpdateMethod#DELTA_TRANSFER}.
     * @param strategy the strategy
     */
    public void setChosenDeltaTransferStrategy(Strategy strategy) {
        this.chosenDeltaTransferStrategy = strategy;
        this.chosenUpdateMethod = UpdateMethod.DELTA_TRANSFER;
    }

    /**
     * Sets the {@link Strategy} that was ultimately chosen for sending a
     * delta-based transfer. The {@link UpdateMethod} is automatically set to
     * {@link UpdateMethod#FULL_TRANSFER}.
     * @param compressionEngineId the ID of the compression engine
     */
    public void setChosenFullTransferCompressionEngineId(int compressionEngineId) {
        this.chosenFullTransferCompressionEngineId = compressionEngineId;
        this.chosenUpdateMethod = UpdateMethod.FULL_TRANSFER;
    }

    /**
     * Sets the {@link PatchCommand} that was ultimately generated for the
     * resource.
     * @param command the command
     */
    public void setCommand(PatchCommand command) {
        this.command = command;
    }

    /**
     * Sets the flag indicating that delta generation was attempted for the
     * resource.
     * @param value the value to set
     */
    public void setDeltaGenerationAttempted(boolean value) {
        deltaGenerationAttempted = value;
    }

    /**
     * Sets the flag indicating that compression was attempted for the
     * resource.
     * @param value the value to set
     */
    public void setDeltaCompressionAttempted(boolean value) {
        deltaCompressionAttempted = value;
    }

    /**
     * Returns the command that was generated for the resource.
     * @return the command
     */
    public PatchCommand getCommand() {
        return command;
    }

    /**
     * Returns the path for the resource in the old archive.
     * @return the path
     */
    public String getOldPath() {
        return oldPath;
    }

    /**
     * Returns the path for the resource in the new archive.
     * @return the path
     */
    public String getNewPath() {
        return newPath;
    }

    /**
     * Returns the size of the entry in the old archive, in bytes.
     * @return the size
     */
    public int getOldArchiveSizeBytes() {
        return oldArchiveSizeBytes;
    }

    /**
     * Returns the ID of the compression engine used to compress the resource
     * in the old archive.
     * @return the ID
     */
    public int getOldArchiveCompressionEngineId() {
        return oldArchiveCompressionEngineId;
    }

    /**
     * Returns the ID of the entry in the new archive, in bytes.
     * @return the size
     */
    public int getNewArchiveSizeBytes() {
        return newArchiveSizeBytes;
    }

    /**
     * Returns the ID of the compression engine used to compress the resource
     * in the new archive.
     * @return the ID
     */
    public int getNewArchiveCompressionEngineId() {
        return newArchiveCompressionEngineId;
    }

    /**
     * Returns a mapping of the strategies attempted to the sizes they produced
     * for this entry.
     * @return such a mapping
     */
    public Map<Strategy, Integer> getDeltaSizeBytesByStrategy() {
        return deltaSizeBytesByStrategy;
    }

    /**
     * Returns the {@link UpdateMethod} that was chosen for this resource.
     * @return the method
     */
    public UpdateMethod getChosenUpdateMethod() {
        return chosenUpdateMethod;
    }

    /**
     * Returns the {@link Strategy} that was chosen for this resource, if the
     * {@link UpdateMethod} was {@link UpdateMethod#DELTA_TRANSFER}.
     * @return the strategy, or null
     */
    public Strategy getChosenDeltaTransferStrategy() {
        return chosenDeltaTransferStrategy;
    }

    /**
     * Returns the ID of the compression engine that was chosen for the full
     * transfer of this resource, if the {@link UpdateMethod} was
     * {@link UpdateMethod#FULL_TRANSFER}.
     * @return the ID, or null
     */
    public Integer getChosenFullTransferCompressionEngineId() {
        return chosenFullTransferCompressionEngineId;
    }

    /**
     * Returns the ID of the compression engine used for the baseline wire
     * transfer size calculation for this resource.
     * @return the ID of the engine
     */
    public Integer getBaselineWireTransferCompressionEngineId() {
        return baselineWireTransferCompressionEngineId;
    }

    /**
     * Returns the size of the baseline wire transfer form of this resource,
     * in bytes.
     * @return the size
     */
    public Integer getBaselineWireTransferCompressedSize() {
        return baselineWireTransferCompressedSize;
    }

    /**
     * Indicates whether delta generation was attempted for the resource.
     * @return true if it was, otherwise false
     */
    public boolean isDeltaGenerationAttempted() {
        return deltaGenerationAttempted;
    }

    /**
     * Indicates whether compression was attempted on the delta generated for
     * the resource.
     * @return true if it was, otherwise false
     */
    public boolean isDeltaCompressionAttempted() {
        return deltaCompressionAttempted;
    }

    /**
     * Records the results of an attempt to generate a (possibly compressed)
     * delta for the resource. Automatically updates the flags for whether
     * delta generation and/or delta compression were attempted.
     * @param strategy the strategy that was applied
     * @param sizeBytes the resulting size of the (possibly compressed) delta
     */
    public void recordStrategyResult(Strategy strategy, int sizeBytes) {
        deltaSizeBytesByStrategy.put(strategy, sizeBytes);
        if (strategy.getDeltaEngineId() != BuiltInDeltaEngine.NONE.getId()) {
            setDeltaGenerationAttempted(true);
        }
        if (strategy.getCompressionEngineId() != BuiltInCompressionEngine.NONE.getId()) {
            setDeltaCompressionAttempted(true);
        }
    }

    /**
     * Returns the full size of the entry as written to a patch, including any
     * and all fields.
     * @return the size
     */
    public int getFullEntrySizeBytes() {
        return fullEntrySizeBytes;
    }

    /**
     * Sets the full size of the entry as written to a patch, including any and
     * all fields.
     * @param fullEntrySizeBytes the size
     */
    public void setFullEntrySizeBytes(int fullEntrySizeBytes) {
        this.fullEntrySizeBytes = fullEntrySizeBytes;
    }
}